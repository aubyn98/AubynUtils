"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});function c(n){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"children",e=arguments.length>2?arguments[2]:void 0;return n.reduce((u,r,g)=>{const f=u.concat(r,Array.isArray(r[t])&&r[t].length?c(r[t],t,e):[]);return typeof e=="function"&&e(r,g),f},[])}function w(){let n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[],t=arguments.length>1?arguments[1]:void 0,e=arguments.length>2&&arguments[2]!==void 0?arguments[2]:"children",u=null;return n.some((r,g)=>t(r,g)?(u=r,!0):u=w(r[e],t,e)),u}function T(){let n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[],t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"children",e=arguments.length>2&&arguments[2]!==void 0?arguments[2]:"$parent",u=arguments.length>3&&arguments[3]!==void 0?arguments[3]:null,r=arguments.length>4&&arguments[4]!==void 0?arguments[4]:"$index";return n.map((g,f)=>{const a={...g};return a[r]=f,a[e]=u,a[t]=T(g[t],t,e,a,r),a})}function j(n){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"$parent";const e=[n];for(;n=n[t];)e.unshift(n);return e}function A(n,t){let e=arguments.length>2&&arguments[2]!==void 0?arguments[2]:"children";return n.filter(t).map(u=>({...u,[e]:A(u[e],t,e)}))}function K(n,t,e,u){let r=arguments.length>4&&arguments[4]!==void 0?arguments[4]:",",g=arguments.length>5&&arguments[5]!==void 0?arguments[5]:n.length;if(arguments.length>6&&arguments[6]!==void 0?arguments[6]:!0){if(!Array.isArray(n))throw new TypeError("arg1：keys must be an Array!");if(!Array.isArray(t))throw new TypeError("arg2：arr must be an Array!");if(e&&typeof e!="function")throw new TypeError("arg3：callback must be a function!");if(u&&typeof u!="function")throw new TypeError("arg4：callbackAll must be a function!");if(r&&typeof r!="string")throw new TypeError("arg5：join must be a string!");if(g&&typeof g!="number")throw new TypeError("arg6：num must be a number!")}const a=g-1,l=n[a],h=[],o={},y=Array.isArray(l),d={};for(let m=t.length-1;m>=0;m--){const s=t[m];let i=s[l];u&&u(s,m),y&&(i=l.map(E=>s[E]).join(r)),o[i]?(o[i].push(s),e&&e(s,d[i])):(o[i]=[s],e&&e(s,d[i]={}))}const p=Object.keys(o);for(let m=p.length-1;m>=0;m--){const s=p[m],i={key:y?s.split(r):s,value:a!==0?K(n,o[s],e,null,r,a,!1):o[s]};e&&Object.assign(i,d[s]),h.push(i)}return h}function P(n,t){for(let e=n.length-1;e>=0;e--)t(n[e],e)}function b(n,t,e){let u=n[t];n[t]=n[e],n[e]=u}exports.exchangeArrP=b;exports.filterTree=A;exports.findTreeItem=w;exports.flatWithKey=c;exports.getTreePath=j;exports.groupBy=K;exports.reverseForEach=P;exports.treeItemSetParent=T;
